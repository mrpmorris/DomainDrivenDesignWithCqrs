# Domain entities

## EntityBase
Any reference object intended for the DB should descend from this class.
Its purpose is simply to have an `Id` property that is generated by the
entity itself when it is created.

This allows us to set up foreign-key associations if we should need to do so
before the object has first been saved.

The algorithm used to create the `Id` is unique, and will be in chronological
order when saved to an MS SQL database.

## AggregateRoot

Most entities should descend from this class.

In addition to the `Id` inherited from `EntityBase` it has a `Timestamp` property
to help with detecting concurrency issues when updating the database.

### Validation and DataAnnotations

Entities use data annotations such as `[Required]` and `[MaxLength(100)]` to
provide additional information to Entity Framework Core as to how to create
the DB columns required to store their values.

Each `AggregateRoot` class should have a corresponding `AbstractValidator<T>`
class to define rules that can never be violated. If any of those rule are
violated then the app layer should not save to the DB.

These are implemented as `Fluent Validation` rules to allow for complex
business rules.

### Object references

Objects within an `Aggregate` (e.g. `Order` and `OrderLines`) are permitted to
reference each other by type

```
public Order Order { get; private set; }
```

But should reference objects outside of their aggregate by `Id` only

```
public Guid ProductId { get; set; }
```

This isn't a rule set in stone, it is just good Domain Driven Design practice
to ensure we don't end up with spaghetti code.